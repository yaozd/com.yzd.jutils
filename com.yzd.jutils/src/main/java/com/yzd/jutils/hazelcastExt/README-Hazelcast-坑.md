# hazelcast的坑爹事
- [hazelcast的坑爹事](https://blog.csdn.net/hengyunabc/article/details/18514563)
```
# 1.
一个结点出问题，影响整个集群
当集群里某个节点出故障时，比如OOM，CPU100%，没反应之后，集群里发到那个结点的操作就各种超时，各种不正常。这个可以算是hazelcast的一个致命的缺点。
我们线上的集群有30多个结点，随便一个有问题，都会导致整个集群有问题。另外，当集群里有一个应用下线/上线，都会引起数据的迁移，尽管迁移是自动的，但是也是一个不可控的风险。
我们开始时用的是hazelcast2.5.1，后来升级到3.1.3版本。升级后发现两个结点间经常会有网络流量超高的情况，最后发现是merge-policy的配置在3.0只能配置类的全名，而在2.5是可以配置一个简称的。然后在集群里有数据要迁移，进行Merge时，就会因为ClassNotFoundException而失败。而Hazelcast坑爹的地方在于它不断地重试，而且是无停顿地重试，从而导致两个结点之间网络流量超高，甚至超过了100Mbps。
# 2.
版本之间不兼容
版本之间不兼容，不能滚动升级。这就意味着，当升级时，整个集群都要一块重启，这对很多网站来说，是不能忍受的。据说从3.1版本后会保证小版本的兼容性
# 3.
结点之间Merge时，需要反序列化
这个我认为是代码太多导致的混乱。结点之间数据合并时，本来只要比较下数据的版本，时间等就可以了，但是在合并时却把对象反序化出来。如果在Server端没有对应的jar包，则会抛出ClassNotFoundException。
# 4.
更多请点击连接
```

## 使用原则
```
使用最简单的功能
如通知类型应用，eg:push：
1.以实例为单位
2.set集合收集任务
3.netty 推送到指定节点
4.nacos做服务发现
```
