### -问题一：[mysql如果开启事务，一直没有提交，难道就这样一直下去？](https://bbs.csdn.net/topics/392297263)
```
如果一个连接中开启事务切未显示提交或回滚，在不考虑其他因素的前提下，确实应该是只有在连接断开的时候才会回滚。
如果出现锁等待，则是根据innodb_rollback_on_timeout参数进行下一步动作，
如果此参数是off,则会回滚上一条语句，不会提交或回滚，直到显示提交或回滚（事务一直存在，直到连接断开）。
如果此参数是on,在超时后会回滚整个事务。
```
### -问题二:[事务操作过程产生的锁](https://blog.csdn.net/tr1912/article/details/81988459)
```
事务隔离级别为可重复读时，如果有索引（包括主键索引）的时候，以索引列为条件更新数据，会存在间隙锁间隙锁、行锁、下一键锁的问题，从而锁住一些行；如果没有索引，更新数据时会锁住整张表。
注：
更新操作：where=主键索引id+时间戳 （从而锁住一行数据）

```

### -[解决MySQL事务未提交导致死锁报错 避免死锁的方法](https://blog.csdn.net/xuheng8600/article/details/79868122)
```
1.查看当前运行的所有事务
SELECT * FROM information_schema.INNODB_TRX\G
2.查看当前mysql中各个线程状态
show processlist
```

### -事务说明与理解
- [【MySQL】事务和事务引发的问题](https://blog.csdn.net/tr1912/article/details/81988459)
- [MySQL——事务(Transaction)详解](https://blog.csdn.net/w_linux/article/details/79666086)
### -[补充](https://blog.csdn.net/tr1912/article/details/81988459)
```
1、SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异

2、mysql中默认事务隔离级别是可重复读时并不会锁住读取到的行

3、事务隔离级别为读提交时，写数据只会锁住相应的行

4、事务隔离级别为可重复读时，如果有索引（包括主键索引）的时候，以索引列为条件更新数据，会存在间隙锁间隙锁、行锁、下一键锁的问题，从而锁住一些行；如果没有索引，更新数据时会锁住整张表。

5、事务隔离级别为串行化时，读写数据都会锁住整张表

6、隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。 
--------------------- 

```

### [隔离性有隔离级别(4个) ](https://blog.csdn.net/w_linux/article/details/79666086)
```
事物A和事物B之间具有一定的隔离性
隔离性有隔离级别(4个) 
1.读未提交：read uncommitted
2.读已提交：read committed
3.可重复读(默认的隔离级别)：repeatable read
4.串行化：serializable
```